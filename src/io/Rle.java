package io;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * DESIGN_PATTERN : Lazy implementation for toWorldState. using cached
 *
 * @author Ahmed Alshakh <ahmed.s.alshakh@gmail.com>
 */
public class Rle {

    public static int LINE_WIDTH_LIMIT = 70;
    public static char LIVE = 'o';
    public static char DEAD = 'b';
    public static char EOL = '$'; // end of line.
    public static char EOF = '!';

    private final String rleFileContents;
    private WorldState myCechedWorldState = null;

    public Rle(String contents) {
        this.rleFileContents = contents;
    }

    public String getContents() {
        return rleFileContents;
    }
    // \s*x\s*=\s*(\d+)\s*,\s*y\s*=\s*(\d+)\s*,\s*rule\s*=\s*([\w\/]+)
    static final String RULE_REGEX = "\\s*x\\s*=\\s*(\\d+)\\s*,\\s*y\\s*=\\s*(\\d+)\\s*,\\s*rule\\s*=\\s*([\\w\\/]+)";
    static final Pattern RULE_PATTERN = Pattern.compile(RULE_REGEX);

    /**
     *
     * @return
     */
    public WorldState toWorldState() {
        if (myCechedWorldState != null) {
            return myCechedWorldState;
        }
        boolean[][] data = null;
        boolean inited = false;
        int X = 0, Y = 0; // size of file.
        int x = 0, y = 0;       //  Current position
        int k = 0;       //  Repeat count
        String rule = "B3/S32";
        for (String line : rleFileContents.split("\\n")) {
            line = line.trim();
            // discard empty lines
            if (line.isEmpty()) {
                continue;
            }
            //  Skip header (starts with #)
            if (line.startsWith("#")) {
                continue;
            }
            // Read header info
            Matcher tmpM = RULE_PATTERN.matcher(line);
            if (tmpM.matches()) {
                X = Integer.parseInt(tmpM.group(1));
                Y = Integer.parseInt(tmpM.group(2));
                rule = tmpM.group(3);
                data = new boolean[Y][X];
                inited = true;
                continue;
            }
            // Shouldn't reach this point with inited == false. can add in empty array.
            if (!inited) {
                return null; // Big Problem. !!!!!! no header line.
            }//
            // start filling data.
            for (char ch : line.toCharArray()) {
                if (ch == Rle.EOF) {
                    break; // end of file marker.
                }
                //  Live cell(s)
                if (ch == Rle.LIVE) {
                    //  k==0 => one
                    if (k <= 0) {
                        k = 1;
                    }
                    //  Draw k live cells in a row
                    for (int i = 0; i < k; i++) {
                        data[y][x + i] = true;
                    }
                    x += k;
                    k = 0;
                } //  Dead cell(s)
                else if (ch == Rle.DEAD) {
                    x += (k > 0 ? k : 1);
                    k = 0;
                } //  End of Line
                else if (ch == Rle.EOL) {
                    y += (k > 0 ? k : 1);
                    x = 0;
                    k = 0;
                } //  Repeat count
                else if (Character.isDigit(ch)) {
                    k = 10 * k + Integer.parseInt(String.valueOf(ch));
                }
            }
        }
        myCechedWorldState = new WorldState(X, Y, rule, data);
        return myCechedWorldState;
    }

    public static Rle createRle(int X, int Y, String rule, boolean[][] data) {

        StringBuilder sb = new StringBuilder();
        sb.append("# generated by GameOfLife : github.com/alshakh/GameOfLifeOOp").append("\n");
        // header
        sb.append("x=").append(X).append(", y=").append(Y).append(", rule=").append(rule).append("\n");
        //
        sb.append(run(data));
        return new Rle(sb.toString());
    }

    private static String run(boolean[][] data) {
        //
        StringBuilder stringData = new StringBuilder();

        for (boolean[] ba : data) {
            for (boolean cell : ba) {
                stringData.append((cell ? Rle.LIVE : Rle.DEAD));
            }
            stringData.append(Rle.EOL);
        }
        stringData.append(Rle.EOF);
        //

        // Compress.
        StringBuilder compressedData = new StringBuilder();
        for (int i = 0; i < stringData.length(); i++) {
            int runLength = 1;
            while (i + 1 < stringData.length() && stringData.charAt(i) == stringData.charAt(i + 1)) {
                runLength++;
                i++;
            }
            if(runLength>1) compressedData.append(runLength); 
            compressedData.append(stringData.charAt(i));
        }
        // fix output line length
        int lineCount = compressedData.length()/Rle.LINE_WIDTH_LIMIT;
        
        for ( int i = 0 ; i < lineCount ; i++) {
            compressedData.insert(Rle.LINE_WIDTH_LIMIT*i+i, '\n');
        }
        
        if(compressedData.charAt(compressedData.length()-1) == '\n') compressedData.deleteCharAt(compressedData.length()-1);
        return compressedData.toString();
    }
}
